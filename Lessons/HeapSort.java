package Lessons;

import java.util.Random;

/* ДЗ
1. Реализовать алгоритм пирамидальной сортировки (сортировка кучей). 
Общая идея сортировки пирамидой заключается в том, что сравнение элементов происходит не между всеми элементами массива,
а только в пределах построенной пирамидальной структуры, т.е. родителя и его детей. 
Такая операция называется «просеиванием», когда интересующий нас узел кучи сравнивается со своими двумя детьми и меняется местами с тем, 
что больше родителя. Если оба ребенка больше родителя – обмен происходит с наибольшим из детей. 
Весь процесс пирамидальной сортировки делим на 2 этапа. 
* Первый этап – это подготовка кучи. Определяем правуючасть кучи по формуле n/2-1, где n – длина массива.
Начиная с указанного индекса,мы начинаем операции просеивания в цикле до тех пор, пока не придем к началу массива. 
В результате этой операции самый большой элемент нашего массива окажется в индексе 0, что является вершиной пирамиды. 
* Второй этап – начинается с того, что первый и последний элемент массива меняется местами, тем самым наибольший элемент оказывается в конце массива, 
а текущая вершина (индекс 0) начинает операцию просеивания по пирамиде с размером n-1,
в результате чего снова наибольший элемент займет 0 индекс нашего массива. 
Меняем его местами с предпоследним элементом массива (последниймы уже определи) и повторяем операцию. 
Это происходит до тех пор, пока все элементы массива не займут свое место, а размер пирамиды для просеивания не уменьшится до 0.*/


public class HeapSort {
    public static void main(String[] args) {
        int[] array = new int[10];           // создаем массив на 10 элементов
        randomizeArray(array);
        System.out.println("Рандомый массив: ");
        print(array);
        sort(array);
        System.out.println("Сортировка кучей: ");
        print(array);
    }


    public static void sort(int[] array) {
        // Построение кучи
        for(int i = array.length / 2 - 1; i >= 0; i--)
        heap(array, array.length, i);

        // Один хза другим извлекаем элементы из кучи
        for(int i = array.length - 1; i >= 0; i--){
            // Перемещаем текущий корень в конец
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;

            // Вызываем процедуру heap на меньшенной куче
            heap(array, i, 0);
        }
    }


    public static void heap(int[] array, int heapSize, int rootIndex) {
        // Инициализируем наибольший элемент как корень
        int lagest = rootIndex; 
        // Индексы его дочерних элементов / дети - 2 * rootIndex + 1 и 2 * rootIndex + 2 
        int leftKid = 2 * rootIndex + 1;
        int rightKid = 2 * rootIndex + 2;

        // Если левый дочерний элемент больше корня
        if(leftKid < heapSize && array[leftKid] > array[lagest])
            lagest = leftKid;

        // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
        if(rightKid < heapSize && array[rightKid] > array[lagest])
            lagest = rightKid;

        // Если самый большой элемент не корень
        if(lagest != rootIndex) {
            int temp = array[rootIndex];
            array[rootIndex] = array[lagest];
            array[lagest] = temp;

        // Рекурсивно перобразуем в двоичную кучу затронутое поддерево
        heap(array, heapSize, lagest);

        }
    }
    public static void randomizeArray(int[] array){    // метод для заполнения массива
        for (int i = 0; i < array.length; i++){
            array[i] = new Random().nextInt(10);
        }
    }
    
    public static void print(int[] array){    // метод для распечатывания массива
        for (int i = 0; i < array.length; i ++){
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
    
}
